# -*- coding: utf-8 -*-
"""Copy of NEW FINAL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b6i7_A3vnUBVEHRuZWQULOW84MESS8mW
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler, MinMaxScaler
import gradio as gr
import io
from PIL import Image
import os

df = None
thresholds = {}
thresholds_rul = {}
OPERATING_HOURS_PER_DAY = 16  # Example: Machine runs 16 hours a day
ESTIMATED_TOTAL_LIFESPAN_HOURS = 5000  # Total expected machine lifespan

# Function to create a plot and return it as an image
def create_plot_image(plot_function):
    plt.figure(figsize=(10, 6))
    plot_function()
    plt.tight_layout()
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)
    pil_img = Image.open(buf)
    plt.close()
    return pil_img

# Load data function for Gradio interface
def load_dataset(file):
    global df, thresholds, thresholds_rul
    
    try:
        # Load the Excel file
        df = pd.read_excel(file.name, header=1)
        
        # Rename columns
        columns = [
            "TimeStamp", "Temperature", "X_RMS_Vel", "Z_RMS_Vel", "X_Peak_Vel",
            "Z_Peak_Vel", "X_RMS_Accel", "Z_RMS_Accel", "X_Peak_Accel", "Z_Peak_Accel"
        ]
        df.columns = columns
        
        # Convert Timestamp column to datetime format
        df["TimeStamp"] = pd.to_datetime(df["TimeStamp"])
        
        # Handle missing values
        df = df.dropna()
        
        # Define threshold using the 95th percentile
        thresholds = {
            'Temperature': np.percentile(df['Temperature'].dropna(), 95),
            'X_RMS_Vel': np.percentile(df['X_RMS_Vel'].dropna(), 95),
            'Z_RMS_Vel': np.percentile(df['Z_RMS_Vel'].dropna(), 95)
        }
        
        # Define thresholds for RUL calculation
        thresholds_rul = {
            'Temperature': 100,  # Example threshold value (adjust as needed)
            'X_RMS_Vel': 0.5,
            'Z_RMS_Vel': 0.5
        }
        
        # Define rolling statistics to analyze degradation trends
        window_size = 30  # Adjust based on data frequency
        df['Temp_mean'] = df['Temperature'].rolling(window=window_size).mean()
        df['X_RMS_Vel_mean'] = df['X_RMS_Vel'].rolling(window=window_size).mean()
        df['Z_RMS_Vel_mean'] = df['Z_RMS_Vel'].rolling(window=window_size).mean()
        
        # Identify degradation points
        df['Temp_alert'] = df['Temperature'] > thresholds['Temperature']
        df['X_RMS_Vel_alert'] = df['X_RMS_Vel'] > thresholds['X_RMS_Vel']
        df['Z_RMS_Vel_alert'] = df['Z_RMS_Vel'] > thresholds['Z_RMS_Vel']
        
        # RUL Estimation Function
        def estimate_rul(data, threshold):
            """Estimate Remaining Useful Life (RUL) as a percentage."""
            return np.maximum(0, (1 - (data / threshold)) * 100)
        
        # Compute RUL for all relevant parameters
        for param in thresholds_rul.keys():
            if param in df.columns:  # Ensure column exists before calculating RUL
                df[f'{param}_rul'] = estimate_rul(df[param], thresholds_rul[param])

        # Return success message
        return f"✅ Data loaded successfully! Dataset contains {len(df)} samples."
    
    except Exception as e:
        return f"❌ Error loading data: {str(e)}"

# Data overview function
def show_data_overview():
    global df
    
    if df is None:
        return "⚠️ Please load data first."
    
    data_info = f"""
    ## Dataset Overview
    
    * Total Samples: {len(df)}
    * Time Range: {df['TimeStamp'].min()} to {df['TimeStamp'].max()}
    * Missing Values: {df.isnull().sum().sum()}
    
    ### Statistical Summary
    
    Temperature:   Min: {df['Temperature'].min():.2f}, Max: {df['Temperature'].max():.2f}, Avg: {df['Temperature'].mean():.2f}
    X_RMS_Vel:     Min: {df['X_RMS_Vel'].min():.2f}, Max: {df['X_RMS_Vel'].max():.2f}, Avg: {df['X_RMS_Vel'].mean():.2f}
    Z_RMS_Vel:     Min: {df['Z_RMS_Vel'].min():.2f}, Max: {df['Z_RMS_Vel'].max():.2f}, Avg: {df['Z_RMS_Vel'].mean():.2f}
    """
    return data_info

# Show histograms
def show_distributions():
    global df
    
    if df is None:
        return None
    
    def plot_func():
        sns.histplot(df["Temperature"], bins=50, kde=True, color='r', label='Temperature')
        sns.histplot(df["X_RMS_Vel"], bins=50, kde=True, color='b', label='X_RMS_Vel')
        sns.histplot(df["Z_RMS_Vel"], bins=50, kde=True, color='g', label='Z_RMS_Vel')
        plt.legend()
        plt.title("Sensor Data Distribution")
    
    return create_plot_image(plot_func)

# Show correlation heatmap
def show_correlation_heatmap():
    global df
    
    if df is None:
        return None
    
    def plot_func():
        sns.heatmap(df.drop(columns=["TimeStamp"]).corr(), annot=True, cmap='coolwarm', fmt='.2f')
        plt.title("Feature Correlation Heatmap")
    
    return create_plot_image(plot_func)

# Show degradation visualization
def show_degradation_plot():
    global df, thresholds
    
    if df is None:
        return None
    
    def plot_func():
        plt.plot(df['Temperature'], label='Temperature', color='r', alpha=0.6)
        plt.axhline(thresholds['Temperature'], color='r', linestyle='--', label='Temp Threshold')
        plt.plot(df['X_RMS_Vel'], label='X_RMS_Vel', color='b', alpha=0.6)
        plt.axhline(thresholds['X_RMS_Vel'], color='b', linestyle='--', label='X_RMS_Vel Threshold')
        plt.plot(df['Z_RMS_Vel'], label='Z_RMS_Vel', color='g', alpha=0.6)
        plt.axhline(thresholds['Z_RMS_Vel'], color='g', linestyle='--', label='Z_RMS_Vel Threshold')
        plt.legend()
        plt.title('Sensor Data with Degradation Thresholds')
    
    return create_plot_image(plot_func)

# Show RUL plots
def show_rul_plots():
    global df
    
    if df is None or 'Temperature_rul' not in df.columns:
        return [None, None, None]
    
    def plot_temp_rul():
        plt.plot(df['Temperature_rul'], label='Temperature RUL', color='r')
        plt.title('Temperature Remaining Useful Life (RUL)')
        plt.xlabel('Time')
        plt.ylabel('RUL Percentage')
        plt.legend()
    
    def plot_x_vel_rul():
        plt.plot(df['X_RMS_Vel_rul'], label='X_RMS_Vel RUL', color='b')
        plt.title('X_RMS_Vel Remaining Useful Life (RUL)')
        plt.xlabel('Time')
        plt.ylabel('RUL Percentage')
        plt.legend()
    
    def plot_z_vel_rul():
        plt.plot(df['Z_RMS_Vel_rul'], label='Z_RMS_Vel RUL', color='g')
        plt.title('Z_RMS_Vel Remaining Useful Life (RUL)')
        plt.xlabel('Time')
        plt.ylabel('RUL Percentage')
        plt.legend()
    
    temp_img = create_plot_image(plot_temp_rul)
    x_vel_img = create_plot_image(plot_x_vel_rul)
    z_vel_img = create_plot_image(plot_z_vel_rul)
    
    return [temp_img, x_vel_img, z_vel_img]

# Function to predict RUL based on user input and show results
def predict_rul_interactive(temperature, x_rms_vel, z_rms_vel):
    global OPERATING_HOURS_PER_DAY, ESTIMATED_TOTAL_LIFESPAN_HOURS
    
    predicted_temperature_rul = max(0, 100 - (temperature * 0.5) + np.random.uniform(-5, 5))
    predicted_x_rms_vel_rul = max(0, 100 - (x_rms_vel * 0.7) + np.random.uniform(-5, 5))
    predicted_z_rms_vel_rul = max(0, 100 - (z_rms_vel * 0.6) + np.random.uniform(-5, 5))
    
    # Calculate time metrics
    temp_hours = (predicted_temperature_rul / 100) * ESTIMATED_TOTAL_LIFESPAN_HOURS
    temp_days = temp_hours / OPERATING_HOURS_PER_DAY
    temp_weeks = temp_days / 7
    temp_months = temp_days / 30
    
    x_vel_hours = (predicted_x_rms_vel_rul / 100) * ESTIMATED_TOTAL_LIFESPAN_HOURS
    x_vel_days = x_vel_hours / OPERATING_HOURS_PER_DAY
    x_vel_weeks = x_vel_days / 7
    x_vel_months = x_vel_days / 30
    
    z_vel_hours = (predicted_z_rms_vel_rul / 100) * ESTIMATED_TOTAL_LIFESPAN_HOURS
    z_vel_days = z_vel_hours / OPERATING_HOURS_PER_DAY
    z_vel_weeks = z_vel_days / 7
    z_vel_months = z_vel_days / 30
    
    # Calculate cumulative RUL (minimum of all)
    cumulative_rul = min(predicted_temperature_rul, predicted_x_rms_vel_rul, predicted_z_rms_vel_rul)
    cum_hours = (cumulative_rul / 100) * ESTIMATED_TOTAL_LIFESPAN_HOURS
    cum_days = cum_hours / OPERATING_HOURS_PER_DAY
    cum_weeks = cum_days / 7
    cum_months = cum_days / 30
    
    # Create a visualization of the results
    def plot_rul_comparison():
        labels = ['Temperature', 'X_RMS_Vel', 'Z_RMS_Vel', 'Cumulative']
        values = [predicted_temperature_rul, predicted_x_rms_vel_rul, predicted_z_rms_vel_rul, cumulative_rul]
        colors = ['red', 'blue', 'green', 'purple']
        
        plt.figure(figsize=(10, 6))
        bars = plt.bar(labels, values, color=colors)
        plt.title('RUL Comparison (%) - Lower Values Indicate Higher Priority for Maintenance')
        plt.ylabel('Remaining Useful Life (%)')
        plt.ylim(0, 100)
        
        for bar in bars:
            height = bar.get_height()
            plt.text(bar.get_x() + bar.get_width()/2., height + 1,
                     f'{height:.1f}%', ha='center', va='bottom')
    
    rul_chart = create_plot_image(plot_rul_comparison)
    
    # Prepare results table
    results_df = pd.DataFrame({
        'Feature': ['Temperature', 'X_RMS_Vel', 'Z_RMS_Vel', 'Cumulative'],
        'RUL (%)': [
            f"{predicted_temperature_rul:.1f}%", 
            f"{predicted_x_rms_vel_rul:.1f}%", 
            f"{predicted_z_rms_vel_rul:.1f}%",
            f"{cumulative_rul:.1f}%"
        ],
        'Hours': [
            f"{temp_hours:.1f}", 
            f"{x_vel_hours:.1f}", 
            f"{z_vel_hours:.1f}",
            f"{cum_hours:.1f}"
        ],
        'Days': [
            f"{temp_days:.1f}", 
            f"{x_vel_days:.1f}", 
            f"{z_vel_days:.1f}",
            f"{cum_days:.1f}"
        ],
        'Weeks': [
            f"{temp_weeks:.1f}", 
            f"{x_vel_weeks:.1f}", 
            f"{z_vel_weeks:.1f}",
            f"{cum_weeks:.1f}"
        ],
        'Months': [
            f"{temp_months:.1f}", 
            f"{x_vel_months:.1f}", 
            f"{z_vel_months:.1f}",
            f"{cum_months:.1f}"
        ]
    })
    
    # Alert message based on cumulative RUL
    alert_message = ""
    if cumulative_rul < 10:
        alert_message = "⚠️ CRITICAL: Immediate maintenance required! Equipment failure imminent."
    elif cumulative_rul < 25:
        alert_message = "⚠️ WARNING: Schedule maintenance soon. Equipment showing significant wear."
    elif cumulative_rul < 50:
        alert_message = "⚠️ CAUTION: Equipment showing signs of degradation. Plan maintenance in the coming weeks."
    else:
        alert_message = "✅ Equipment in good condition. No immediate maintenance required."
    
    # Format the results table as markdown
    results_table = results_df.to_markdown(index=False)
    
    # Combine everything into one output
    complete_output = f"""
    ## RUL Prediction Results
    
    {alert_message}
    
    ### Detailed Results:
    
    {results_table}
    
    **Note:** RUL (Remaining Useful Life) is calculated based on current sensor readings. Lower values indicate higher priority for maintenance.
    """
    
    return rul_chart, complete_output

# Function to display current thresholds
def show_current_thresholds():
    global thresholds
    
    if not thresholds:
        return "⚠️ Please load data first to calculate thresholds."
    
    thresholds_text = f"""
    ### Current Thresholds
    
    - Temperature: {thresholds['Temperature']:.2f}
    - X_RMS_Velocity: {thresholds['X_RMS_Vel']:.2f}
    - Z_RMS_Velocity: {thresholds['Z_RMS_Vel']:.2f}
    
    These thresholds are calculated as the 95th percentile of each parameter.
    """
    
    return thresholds_text

# Create the Gradio interface
with gr.Blocks(title="Industrial Equipment Monitoring & RUL Prediction") as demo:
    gr.Markdown("# Industrial Equipment Monitoring & RUL Prediction")
    gr.Markdown("This dashboard provides tools to monitor equipment health and predict remaining useful life.")
    
    with gr.Tabs():
        with gr.TabItem("Load Data"):
            gr.Markdown("### Upload Dataset")
            gr.Markdown("Upload your sensor data in Excel format (.xlsx)")
            
            file_input = gr.File(label="Upload Excel file", file_types=[".xlsx"])
            load_button = gr.Button("Load Dataset")
            load_output = gr.Markdown()
            
            load_button.click(
                fn=load_dataset,
                inputs=file_input,
                outputs=load_output
            )
            
        with gr.TabItem("Data Overview"):
            gr.Markdown("### Dataset Overview and Exploratory Analysis")
            overview_output = gr.Markdown()
            overview_btn = gr.Button("Show Data Overview")
            overview_btn.click(fn=show_data_overview, outputs=overview_output)
            
            with gr.Row():
                with gr.Column():
                    gr.Markdown("### Data Distribution")
                    dist_output = gr.Image()
                    dist_btn = gr.Button("Show Data Distributions")
                    dist_btn.click(fn=show_distributions, outputs=dist_output)
                
                with gr.Column():
                    gr.Markdown("### Correlation Heatmap")
                    corr_output = gr.Image()
                    corr_btn = gr.Button("Show Correlation Heatmap")
                    corr_btn.click(fn=show_correlation_heatmap, outputs=corr_output)
        
        with gr.TabItem("Sensor Monitoring"):
            gr.Markdown("### Equipment Sensor Monitoring with Thresholds")
            deg_output = gr.Image()
            deg_btn = gr.Button("Show Sensor Data with Thresholds")
            deg_btn.click(fn=show_degradation_plot, outputs=deg_output)
            
            gr.Markdown("### Current Thresholds")
            thresholds_md = gr.Markdown()
            thresh_btn = gr.Button("Show Current Thresholds")
            thresh_btn.click(fn=show_current_thresholds, outputs=thresholds_md)
        
        with gr.TabItem("RUL Analysis"):
            gr.Markdown("### Remaining Useful Life (RUL) Analysis")
            
            with gr.Row():
                rul_outputs = [gr.Image() for _ in range(3)]
            
            rul_btn = gr.Button("Show RUL Plots")
            rul_btn.click(fn=show_rul_plots, outputs=rul_outputs)
        
        with gr.TabItem("Predict RUL"):
            gr.Markdown("### Predict Remaining Useful Life")
            gr.Markdown("Enter current sensor values to predict the remaining useful life")
            
            with gr.Row():
                with gr.Column():
                    temp_input = gr.Slider(minimum=0, maximum=150, value=50, step=1, label="Temperature")
                    x_vel_input = gr.Slider(minimum=0, maximum=2, value=0.25, step=0.01, label="X RMS Velocity")
                    z_vel_input = gr.Slider(minimum=0, maximum=2, value=0.25, step=0.01, label="Z RMS Velocity")
                    predict_btn = gr.Button("Predict RUL")
                
                with gr.Column():
                    rul_viz_output = gr.Image()
                    rul_text_output = gr.Markdown()
            
            predict_btn.click(
                fn=predict_rul_interactive,
                inputs=[temp_input, x_vel_input, z_vel_input],
                outputs=[rul_viz_output, rul_text_output]
            )

# Launch the interface
if __name__ == "__main__":
    print("Starting Gradio interface on http://127.0.0.1:7860")
    demo.launch()